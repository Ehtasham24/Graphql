"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateQueries = exports.validateQueryFiles = exports.loadQueryFiles = exports.validateQuery = exports.validateOperations = exports.mergeGQLSchemas = void 0;
const graphql_1 = require("graphql");
const utils = require("./utilities");
var cli_1 = require("./cli");
Object.defineProperty(exports, "mergeGQLSchemas", { enumerable: true, get: function () { return cli_1.mergeGQLSchemas; } });
Object.defineProperty(exports, "validateOperations", { enumerable: true, get: function () { return cli_1.validateOperations; } });
function validateQuery(schema, document, rules) {
    if (!rules) {
        return (0, graphql_1.validate)(schema, document);
    }
    else {
        return (0, graphql_1.validate)(schema, document, rules);
    }
}
exports.validateQuery = validateQuery;
function loadQueryFiles(glob, callback) {
    return new Promise((resolve, reject) => {
        function loadAll(files) {
            const promises = files.map(utils.readFile);
            return Promise.all(promises)
                .then((fileResults) => {
                const docs = fileResults.map((text, index) => (0, graphql_1.parse)(text));
                callback ? callback(null, docs) : resolve(docs);
            })
                .catch((err) => (callback ? callback(err) : reject(err)));
        }
        if (glob instanceof Array) {
            loadAll(glob);
        }
        else {
            utils
                .readGlob(glob)
                .then(loadAll)
                .catch((err) => (callback ? callback(err) : reject(err)));
        }
    });
}
exports.loadQueryFiles = loadQueryFiles;
function validateQueryFiles(glob, schema, rules, callback) {
    return new Promise((resolve, reject) => {
        let queries;
        utils
            .readGlob(glob)
            .then((files) => {
            queries = files;
            return loadQueryFiles(files);
        })
            .then((docs) => {
            const errors = validateQueries(docs, schema, rules, queries);
            if (errors.length) {
                callback ? callback(errors) : reject(errors);
            }
            else {
                callback ? callback(null, queries) : resolve(queries);
            }
        })
            .catch((err) => {
            const errs = [
                {
                    errors: [err.toString()],
                    file: '',
                },
            ];
            callback ? callback(errs) : reject(errs);
        });
    });
}
exports.validateQueryFiles = validateQueryFiles;
function validateQueries(docs, schema, rules, files) {
    const results = [];
    docs.forEach((doc, index) => {
        const errs = validateQuery(schema, doc, rules);
        if (errs.length) {
            results.push({
                errors: errs.map((err) => err.toString()),
                file: files ? files[index] : '',
            });
        }
    });
    return results;
}
exports.validateQueries = validateQueries;
//# sourceMappingURL=index.js.map