"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSchemaWithSourceMap = void 0;
const chalk_1 = require("chalk");
const graphql_tools_1 = require("graphql-tools");
const logger_1 = require("./logger");
const validateSchemaWithSourceMap = (map) => {
    let errorCounter = 0;
    const listOfErrors = [];
    const errorsSeparator = '\n\n';
    const listOfSchemas = Array.from(map.values());
    const fileNames = Array.from(map.keys());
    try {
        const mergedSchema = (0, graphql_tools_1.makeExecutableSchema)({ typeDefs: listOfSchemas });
        return mergedSchema;
    }
    catch (allErrors) {
        const allErrorsMessages = allErrors.message;
        const allErrorsList = allErrorsMessages.split(errorsSeparator);
        const errorListClone = allErrorsList.slice();
        let listOfUnMappedErrors = allErrorsList.slice();
        for (let i = 0; i < listOfSchemas.length; i++) {
            try {
                const fileSchema = (0, graphql_tools_1.makeExecutableSchema)({ typeDefs: listOfSchemas[i] });
            }
            catch (error) {
                const errorsMessages = error.message;
                const errorsList = errorsMessages.split(errorsSeparator);
                errorsList.forEach((errorItem) => {
                    allErrorsList.forEach((allErrorsItem, x) => {
                        const locations = error.locations;
                        if (allErrorsItem.includes(errorItem) || error.locations) {
                            listOfErrors.push(constructErrorMessage(++errorCounter, errorItem, fileNames[i]));
                            listOfUnMappedErrors = popError(listOfUnMappedErrors, errorItem);
                            if (locations) {
                                logger_1.consoleLogger.error('Location of errors: ', locations);
                            }
                            const index = errorListClone.indexOf(allErrorsItem);
                            if (index > -1) {
                                errorListClone.splice(index, 1);
                            }
                        }
                    });
                });
            }
        }
        for (let i = 0; i < listOfSchemas.length; i++) {
            try {
                const schemaWithoutFilei = listOfSchemas.slice();
                const index = schemaWithoutFilei.indexOf(listOfSchemas[i]);
                if (index > -1) {
                    schemaWithoutFilei.splice(index, 1);
                }
                const mergedSchemaWithoutFile = (0, graphql_tools_1.makeExecutableSchema)({
                    typeDefs: schemaWithoutFilei,
                });
                errorListClone.forEach((errorItem) => {
                    listOfErrors.push(constructErrorMessage(++errorCounter, errorItem, fileNames[i]));
                    listOfUnMappedErrors = popError(listOfUnMappedErrors, errorItem);
                });
            }
            catch (error) {
                const errorsMessages = error.message;
                const errorsList = errorsMessages.split(errorsSeparator);
                errorListClone.forEach((errorItem) => {
                    if (errorsList.indexOf(errorItem) < 0) {
                        listOfErrors.push(constructErrorMessage(++errorCounter, errorItem, fileNames[i]));
                        listOfUnMappedErrors = popError(listOfUnMappedErrors, errorItem);
                    }
                });
            }
        }
        if (errorCounter) {
            listOfUnMappedErrors.forEach((errorItem) => {
                logger_1.consoleLogger.error(`>> Error(${++errorCounter}): ${errorItem}.`);
            });
            logger_1.consoleLogger.log(`>> Total numbers of errors found: ${errorCounter +
                listOfUnMappedErrors.length}.`);
            throw new Error(`${listOfErrors}`);
        }
    }
};
exports.validateSchemaWithSourceMap = validateSchemaWithSourceMap;
function getFullPath(fileName) {
    return encodeURI(`file://${process.cwd() + '/' + fileName}`);
}
function constructErrorMessage(errorCounter, errorItem, fileName) {
    const errorMessage = `>> Error(${errorCounter}): ${errorItem} check the file:\n${chalk_1.default.blue.
        underline(getFullPath(fileName))}`;
    logger_1.consoleLogger.error(`${errorMessage}\n`);
    return errorMessage;
}
function popError(errorList, errorItem) {
    return errorList.filter((item) => item !== errorItem);
}
//# sourceMappingURL=validate-schema.js.map