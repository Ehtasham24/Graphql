"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printSchemaDefault = exports.printSchemaWithDirectives = void 0;
const graphql_1 = require("graphql");
const blockString_1 = require("graphql/language/blockString");
const objectValues_1 = require("graphql/polyfills/objectValues");
function printSchemaWithDirectives(schema) {
    return printFilteredSchema(schema, (n) => !(0, graphql_1.isSpecifiedDirective)(n), isDefinedType);
}
exports.printSchemaWithDirectives = printSchemaWithDirectives;
function printSchemaDefault(schema) {
    return (0, graphql_1.printSchema)(schema);
}
exports.printSchemaDefault = printSchemaDefault;
function printFilteredSchema(schema, directiveFilter, typeFilter) {
    const directives = schema.getDirectives().filter(directiveFilter);
    const typeMap = schema.getTypeMap();
    const types = (0, objectValues_1.default)(typeMap)
        .sort((type1, type2) => type1.name.localeCompare(type2.name))
        .filter(typeFilter);
    return ([printSchemaDefinition(schema)]
        .concat(directives.map((directive) => printDirective(directive)), types.map((type) => printType(type)))
        .filter(Boolean)
        .join('\n\n') + '\n');
}
function printType(type) {
    if ((0, graphql_1.isScalarType)(type)) {
        return printScalar(type);
    }
    else if ((0, graphql_1.isObjectType)(type)) {
        return printObject(type);
    }
    else if ((0, graphql_1.isInterfaceType)(type)) {
        return printInterface(type);
    }
    else if ((0, graphql_1.isUnionType)(type)) {
        return printUnion(type);
    }
    else if ((0, graphql_1.isEnumType)(type)) {
        return printEnum(type);
    }
    else if ((0, graphql_1.isInputObjectType)(type)) {
        return printInputObject(type);
    }
    throw Error('Unexpected type: ' + type);
}
function printScalar(type) {
    return printDescription(type) + `scalar ${type.name}`;
}
function printObject(type) {
    const interfaces = type.getInterfaces();
    const implementedInterfaces = interfaces.length
        ? ' implements ' + interfaces.map((i) => i.name).join(' & ')
        : '';
    return (printDescription(type) +
        `type ${type.name}${implementedInterfaces}` +
        printFields(type));
}
function printInterface(type) {
    return (printDescription(type) +
        `interface ${type.name}` +
        printFields(type));
}
function printUnion(type) {
    const types = type.getTypes();
    const possibleTypes = types.length ? ' = ' + types.join(' | ') : '';
    return printDescription(type) + 'union ' + type.name + printDirectiveNode(type.astNode) + possibleTypes;
}
function printEnum(type) {
    const values = type
        .getValues()
        .map((value, i) => printDescription(value, '  ', !i) +
        '  ' +
        value.name +
        printDirectiveField(value));
    return (printDescription(type) + `enum ${type.name}` + printBlock(type, values));
}
function printInputObject(type) {
    const fields = printInputFields(type);
    return (printDescription(type) +
        `input ${type.name}` +
        printBlock(type, fields));
}
function printInputFields(type) {
    return (0, objectValues_1.default)(type.getFields()).map((f, i) => printDescription(f, '  ', !i) +
        '  ' +
        printInputValue(f));
}
function printFields(type) {
    const fields = (0, objectValues_1.default)(type.getFields()).map((f, i) => printDescription(f, '  ', !i) +
        '  ' +
        f.name +
        printArgs(f.args, '  ') +
        ': ' +
        String(f.type) +
        printDirectiveField(f));
    return printBlock(type, fields);
}
function printDirectiveField(field) {
    const node = field.astNode;
    return printDirectiveNode(node);
}
function printDirectiveNode(node) {
    if (!node || !node.directives || node.directives.length === 0) {
        return '';
    }
    const directives = node.directives.map((directive) => {
        let directiveString = '';
        directiveString += ' @';
        directiveString += directive.name.value;
        if (directive.arguments.length > 0) {
            directiveString += '(';
            directive.arguments.forEach((arg, i) => {
                directiveString += printArgument(arg);
                if (i !== directive.arguments.length - 1) {
                    directiveString += ', ';
                }
            });
            directiveString += ')';
        }
        return directiveString;
    });
    return directives.join('');
}
function printArgument(node) {
    return node.name.value
        + ': '
        + printArgumentValueNode(node.value);
}
function printBlock(type, items) {
    const directiveStatement = printDirectiveNode(type.astNode);
    if (items.length !== 0) {
        return directiveStatement + ' {\n' + items.join('\n') + '\n}';
    }
    else {
        return '';
    }
}
function isDefinedType(type) {
    return !(0, graphql_1.isSpecifiedScalarType)(type) && !(0, graphql_1.isIntrospectionType)(type);
}
function printSchemaDefinition(schema) {
    if (isSchemaOfCommonNames(schema)) {
        return;
    }
    const operationTypes = [];
    const queryType = schema.getQueryType();
    if (queryType) {
        operationTypes.push(`  query: ${queryType.name}`);
    }
    const mutationType = schema.getMutationType();
    if (mutationType) {
        operationTypes.push(`  mutation: ${mutationType.name}`);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
        operationTypes.push(`  subscription: ${subscriptionType.name}`);
    }
    return `schema {\n${operationTypes.join('\n')}\n}`;
}
function isSchemaOfCommonNames(schema) {
    const queryType = schema.getQueryType();
    if (queryType && queryType.name !== 'Query') {
        return false;
    }
    const mutationType = schema.getMutationType();
    if (mutationType && mutationType.name !== 'Mutation') {
        return false;
    }
    const subscriptionType = schema.getSubscriptionType();
    return !(subscriptionType && subscriptionType.name !== 'Subscription');
}
function printDirective(directive) {
    return (printDescription(directive) +
        'directive @' +
        directive.name +
        printArgs(directive.args) +
        (directive.isRepeatable ? ' repeatable' : '') +
        ' on ' +
        directive.locations.join(' | '));
}
function printDescription(def, indentation = '', firstInBlock = true) {
    if (!def.description) {
        return '';
    }
    const lines = descriptionLines(def.description, 120 - indentation.length);
    const text = lines.join('\n');
    const preferMultipleLines = text.length > 70;
    const blockString = (0, blockString_1.printBlockString)(text, '', preferMultipleLines);
    const prefix = indentation && !firstInBlock ? '\n' + indentation : indentation;
    return prefix + blockString.replace(/\n/g, '\n' + indentation) + '\n';
}
function printArgs(args, indentation = '') {
    if (args.length === 0) {
        return '';
    }
    if (args.every((arg) => !arg.description)) {
        return '(' + args.map(printInputValue).join(', ') + ')';
    }
    return ('(\n' +
        args
            .map((arg, i) => printDescription(arg, '  ' + indentation, !i) +
            '  ' +
            indentation +
            printInputValue(arg))
            .join('\n') +
        '\n' +
        indentation +
        ')');
}
function printInputValue(arg) {
    const defaultAST = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type);
    let argDecl = arg.name + ': ' + String(arg.type) + printDirectiveField(arg);
    if (defaultAST) {
        argDecl += ` = ${(0, graphql_1.print)(defaultAST)}`;
    }
    return argDecl;
}
function printArgumentValueNode(type) {
    switch (type.kind) {
        case 'BooleanValue':
            return printLiteralArgumentValueNode(type);
        case 'FloatValue':
            return printLiteralArgumentValueNode(type);
        case 'IntValue':
            return printLiteralArgumentValueNode(type);
        case 'NullValue':
            return printNullValueNode(type);
        case 'StringValue':
            return printStringValueNode(type);
        case 'ListValue':
            return printListValueNode(type);
        case 'EnumValue':
            return printEnumValueNode(type);
        case 'ObjectValue':
            return printObjectValueNode(type);
    }
    throw Error('Cannot print complex directive of type: ' + String(type.kind));
}
function printLiteralArgumentValueNode(node) {
    return node.value;
}
function printStringValueNode(node) {
    return '"' + node.value + '"';
}
function printNullValueNode(node) {
    return null;
}
function printListValueNode(node) {
    return '[' + node.values.map(printArgumentValueNode).join(', ') + ']';
}
function printEnumValueNode(node) {
    return node.value;
}
function printObjectValueNode(node) {
    return '{' + node.fields.map(printObjectField).join(', ') + '}';
}
function printObjectField(field) {
    return field.name.value + ': ' + printArgumentValueNode(field.value);
}
function descriptionLines(description, maxLen) {
    const rawLines = description.split('\n');
    const updatedLines = [];
    for (const line of rawLines) {
        if (line.length < maxLen + 5) {
            updatedLines.push(line);
        }
        else {
            const brokenLines = breakLine(line, maxLen);
            for (const brokenLine of brokenLines) {
                updatedLines.push(brokenLine);
            }
        }
    }
    return updatedLines;
}
function breakLine(line, maxLen) {
    const parts = line.split(new RegExp(`((?: |^).{15,${maxLen - 40}}(?= |$))`));
    if (parts.length < 4) {
        return [line];
    }
    const sublines = [parts[0] + parts[1] + parts[2]];
    for (let i = 3; i < parts.length; i += 2) {
        sublines.push(parts[i].slice(1) + parts[i + 1]);
    }
    return sublines;
}
//# sourceMappingURL=printers.js.map